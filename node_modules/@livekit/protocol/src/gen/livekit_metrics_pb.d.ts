// @generated by protoc-gen-es v1.10.0 with parameter "target=js+dts"
// @generated from file livekit_metrics.proto (package livekit, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * index from [0; 512] are for predefined labels (`MetricLabel`)
 *
 * @generated from enum livekit.MetricLabel
 */
export declare enum MetricLabel {
  /**
   * time to first token from LLM
   *
   * @generated from enum value: AGENTS_LLM_TTFT = 0;
   */
  AGENTS_LLM_TTFT = 0,

  /**
   * time to final transcription
   *
   * @generated from enum value: AGENTS_STT_TTFT = 1;
   */
  AGENTS_STT_TTFT = 1,

  /**
   * time to first byte
   *
   * @generated from enum value: AGENTS_TTS_TTFB = 2;
   */
  AGENTS_TTS_TTFB = 2,

  /**
   * @generated from enum value: METRIC_LABEL_MAX_VALUE = 512;
   */
  METRIC_LABEL_MAX_VALUE = 512,
}

/**
 * @generated from message livekit.MetricsBatch
 */
export declare class MetricsBatch extends Message<MetricsBatch> {
  /**
   * To avoid repeating string values, we store them in a separate list and reference them by index
   * This is useful for storing participant identities, track names, etc.
   * There is also a predefined list of labels that can be used to reference common metrics.
   * They have reserved indices from 0 to 512
   *
   * @generated from field: repeated string str_data = 1;
   */
  strData: string[];

  /**
   * @generated from field: repeated livekit.TimeSeriesMetric time_series = 2;
   */
  timeSeries: TimeSeriesMetric[];

  /**
   * @generated from field: repeated livekit.EventMetric events = 3;
   */
  events: EventMetric[];

  constructor(data?: PartialMessage<MetricsBatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "livekit.MetricsBatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsBatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsBatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsBatch;

  static equals(a: MetricsBatch | PlainMessage<MetricsBatch> | undefined, b: MetricsBatch | PlainMessage<MetricsBatch> | undefined): boolean;
}

/**
 * @generated from message livekit.TimeSeriesMetric
 */
export declare class TimeSeriesMetric extends Message<TimeSeriesMetric> {
  /**
   * Metric name e.g "speech_probablity". The string value is not directly stored in the message, but referenced by index
   * in the `str_data` field of `MetricsBatch`
   *
   * @generated from field: uint32 label = 1;
   */
  label: number;

  /**
   * @generated from field: uint32 participant_identity = 2;
   */
  participantIdentity: number;

  /**
   * @generated from field: uint32 track_sid = 3;
   */
  trackSid: number;

  /**
   * samples
   *
   * @generated from field: int64 start_timestamp = 4;
   */
  startTimestamp: bigint;

  /**
   * @generated from field: int64 end_timestamp = 5;
   */
  endTimestamp: bigint;

  /**
   * list of samples between start_timestamp and end_timestamp
   *
   * @generated from field: repeated livekit.MetricSample samples = 6;
   */
  samples: MetricSample[];

  constructor(data?: PartialMessage<TimeSeriesMetric>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "livekit.TimeSeriesMetric";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeriesMetric;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeriesMetric;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeriesMetric;

  static equals(a: TimeSeriesMetric | PlainMessage<TimeSeriesMetric> | undefined, b: TimeSeriesMetric | PlainMessage<TimeSeriesMetric> | undefined): boolean;
}

/**
 * @generated from message livekit.MetricSample
 */
export declare class MetricSample extends Message<MetricSample> {
  /**
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * @generated from field: float value = 2;
   */
  value: number;

  constructor(data?: PartialMessage<MetricSample>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "livekit.MetricSample";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricSample;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricSample;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricSample;

  static equals(a: MetricSample | PlainMessage<MetricSample> | undefined, b: MetricSample | PlainMessage<MetricSample> | undefined): boolean;
}

/**
 * @generated from message livekit.EventMetric
 */
export declare class EventMetric extends Message<EventMetric> {
  /**
   * @generated from field: uint32 label = 1;
   */
  label: number;

  /**
   * @generated from field: uint32 participant_identity = 2;
   */
  participantIdentity: number;

  /**
   * 0 =
   *
   * @generated from field: uint32 track_sid = 3;
   */
  trackSid: number;

  /**
   * @generated from field: int64 start_timestamp = 4;
   */
  startTimestamp: bigint;

  /**
   * @generated from field: optional int64 end_timestamp = 5;
   */
  endTimestamp?: bigint;

  /**
   * @generated from field: string metadata = 6;
   */
  metadata: string;

  constructor(data?: PartialMessage<EventMetric>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "livekit.EventMetric";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventMetric;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventMetric;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventMetric;

  static equals(a: EventMetric | PlainMessage<EventMetric> | undefined, b: EventMetric | PlainMessage<EventMetric> | undefined): boolean;
}

